1. The output of the SimpleThreadExample program generally displays two threads printing greeting messages ("Good morning!" and "Good afternoon!") in an alternating, interleaved order. Each thread prints its designated message 10 times, with each thread announcing its start and exit. But it is not always consistent
 Draw the diagram

2. By adding the Thread.sleep(1000) in GreetingsThread.run() causes each message print to pause for 1 second, making the outputs appear more orderly and spaced. But it is clear that the order in which the threads start and finish changes each time we run the program. Sometimes the "Good morning!" thread starts first, while other times the "Good afternoon!" thread starts first. The same applies to the threads finishing â€” their exit order varies as well.

3. By adding  System.out.println("Main method exiting..."); in main it allows the main method to finish while morningThread and afternoonThread continue running in parallel. Since threads execute independently, they keep printing messages after main has exited, resulting in their output appearing on the Terminal even after main completes.

4. The main thread calls morningThread.join(5000), meaning it waits for up to 5 seconds for morningThread to finish. During this time, morningThread runs and prints "Good morning!" repeatedly. After 5 seconds have passed afternoonThread starts. There are some cases when  Good morning is being printed out after Good afternoon starts. We can say that if  morningThread does not complete within that time, afternoonThread starts regardless.

5. ``` join() ```: Blocks the calling thread until the target thread fully completes, regardless of time.
```join(10)```: Blocks for a maximum of 10 milliseconds, then resumes whether the target thread is finished or not.

6. isAlive() checks if a thread is currently running.
join() pauses the calling thread until the target thread completes
